---
title: "Untitled"
author: "Pablo Hidalgo García"
date: "29/7/2020"
bibliography: bibliography.bib
output: 
  pdf_document:
    toc: false
    number_section: true
    fig_caption: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Introducción

En la compleja sociedad moderna aparecen retos que es necesario abordar y solucionar de la mejor forma posible para que la vida sea fácil y llevadera. Además, existe una conciencia creciente acerca del impacto medioambiental de nuestras actividades por lo que las soluciones a estos retos deben tenerlo en consideración. Uno de esos muchos retos es la gestión de los residuos. La sociedad de consumo moderna implica una alta generación de residuos que es necesario procesar para reducir la huella medioambiental así como evitar la aparición de enfermedades o las incomodidades propias de la convivencia con los residuos. En el año 2017 se recogieron en España más de 22.000 toneladas de residuos (alrededor de 460 kilogramos por habitante) y que da cuenta de la magnitud y la dificultad en la gestión. En áreas rurales o insulares, esta gestión es complicada en el sentido de que los trayectos pueden ser amplios y la frecuencia de recogida no puede ser diaria adaptándose la recogida al comportamiento de la generación de los residuos. Por ello, es fundamental que la recogida de estos residuos se haga de la forma más eficiente posible. Se pueden distinguir dos formas en la que la recogida de los residuos se puede mejorar. La primera de ellas es realizar inversiones que consigan adaptar los recursos e infraestructuras disponibles (camiones de recogida, puntos de recogida, plantas de procesamiento, etcétera) a los patrones de generación de residuos; la segunda es optimizar la recogida contando con los recursos ya existentes. 

Es en este segundo enfoque en el que se incide en este trabajo, en particular en optimizar las rutas que recorren los camiones con el objetivo de recoger la máxima cantidad de residuo conforme a las restricciones de recursos. Las restricciones son:

- plantas de procesamiento,
- puntos de recogida,
- camiones,
- horas de trabajo.

De estas restricciones la más fuerte es el número máximo de horas de trabajo que se consideran de 6.5 horas dejando un margen para cualquier eventualidad. Esta restricción es obvia para que los trabajadores descansen adecuadamente y, además, por la naturaleza de la recogida de residuos, se fomenta la recogida durante los periodos nocturnos para molestar lo menos posible a la población.

Este trabajo se desarrolla en este contexto tomando como escenario de estudio la isla de la Palma (Islas Canarias) aunque su aplicación se puede extender y adaptar a cualquier otra área geográfica. La información disponible son: patrones de generación de residuos, emplazamiento de los contenedores y sus características, detalles de las rutas, tiempo y coste y las restricciones de los recursos disponibles. Existen tres puntos de origen y destino de las rutas situadas en tres municipios de la Palma: Breña Alta, Mazo y Los Llanos. Cada vehículo debe llevar a cabo una ruta diaria y, cada ruta se define como un secuencia de putnos de recogida que deben ser visitados por cada vehículo. Se considera que cada vez que un camión visita un punto de recogida, éste recoge todo el residuo acumulado.

Las principales contribuciones de este trabajo son:

1. Propuesta de un algoritmo metaheurístico híbrido entre una búsqudda tabú y una búsqueda por vecindarios variables.
1. Comparativa del algoritmo propuesto con la ruta real y con EXPÓSITO.
1. Estudio del algoritmo bajo distintos escenarios.


Este trabajo está organizado de la siguiente forma. La sección 2 hace un repaso de la literatura existente

En el problema se han considerado al recogida independiente de dos tipos de residuos: residuos de papel y cartón y residuos plásticos identificados, habitualmente, con los colores marrones y amarillos, respectivamente. Para cada tipo de residuo se considera un camión con un punto de origen y un punto de destino (el almacén y la planta de tratamiento de residuos) y una serie de puntos de recogida candidatos. Cada punto de recogida tiene su propia tasa de llenado que determina el nivel de residuo hasta el punto en el que esté saturado. La restricción principal que hay que abordar es la del tiempo máximo de trabajo que los operarios considerando un tiempo de 6.5 horas. 

Este trabajo toma como punto de partida el ya iniciado en EXPÓSITO. En ese trabajo se aplica modelos metaheurísticos GRASP (greedy randomized adaptative search procedure) para abordar el problema. En este trabajo se se desarrolla un algoritmo híbrido entre la búsqueda tabú y la búsqueda por vecindarios. Además, en EXPÓSITO, los resultados obtenidos se comparan con las rutas existentes en la compañía de recogida de residuos en una semana concreta. En este trabajo, el estudio se extiende para evaluar el comportamiento del algoritmo para distintos escenarios (condiciones iniciales distintas así como distintos horizontes temporales.




El objetivo de este trabajo es el de aplicar algoritmos metaheurísticos en la gestión de las rutas de los residuos como alternativa a lo estudiado en (Expósito).

En este trabajo se ha utilizado un algoritmo híbrido entre la búsqueda tabú y la búsqueda por vecindarios variables (Variable Neighborhood search o VNS).







Durante el año 2017 se recogieron en España más de 22.000 toneladas de residuos. La eficiencia en su recogida hace que 


En el conjunto de la sociedad se presentan retos que es necesario abordar. Por ejemplo, la gestión eficiente del tráfico o la gestión de los residuos. 

Vivimos en una sociedad cada vez más preocupada por el impacto 


**Esquema de la introducción**

1. Problema de la gestión de residuos en general.
1. Características de la gestión en zonas rurales o remotas.
1. Descripción del problema del trabajo.
1. Pinceladas de la solución.
1. Relación con EXPÓSITO.
1. Novedades de este trabajo.


# Revisión bibliográfica

El problema de la recogida de residuos se engloba dentro de los problemas conocidos como Problema de enrutamiento de vehículos (Vehicle Routing Problem o VRT) enunciado por primera vez en [@dantzig_truck_1959] y que puede cosiderarse como una generalización del problema del viajante (Traveling-Salesman Problem o TSP) [@salesman_1956]. En el problema del viajante (TSP en lo que sigue) busca la ruta óptima entre $n$ puntos pasando una única vez por cada uno de ellos. El problema de enrutamiento de vehículos (VRP en lo que sigue) trata de encontrar la mejor ruta para una flota de vehículos (y no solo uno, como en el TSP) para satisfacer la demanda de un conjunto de clientes conforme a un criterio de optimización. Estos dos problemas son fundamentales en el desarrollo de la inteligencia artificial por la cantidad de aplicaciones prácticas. De hecho, se suelen nombrar algunas variaciones de este problema:

(i) Capacitated VRP: está disponible una flota homogénea de vehículos donde la restricción es la capacidad de cada vehículo,
(ii) VRP con ventana de tiempos: los clientes tienen que ser servidos en un intervalo de tiempo específico.

En los problemas VRP tradicionales, el objetivo se trata desde un punto de vista del impacto económico (habitualmente, se define algún tipo de coste). Sin embargo, han surgido una familia de problemas denominados *Green Vehicle Routing Problems* (GVRP) caracterizados por tener en cuenta la armonización entre el impacto económico y medioambiental. Dentro de esta familia de problemas, se pueden ver tres grandes categorías [@lin_survey_2014]:

- G-VRP (Green-VRP): el objetivo es optimizar el consumo de la energía necesaria para el transporte,
- Pollution Routing Problem (PRP): el objetivo es encontrar la mejor planificación de rutas desde el punto de vista de la contaminación, en particular, reduciendo las emisiones de carbono.
- VRP en Reverse Logistics (VRPRL): estos problemas están relacionados con aspectos de la logística inversa (traslado de materiales apra su reciclado, reutilización o destrucción).

El problema de la recogida de residuos se trata en [@exposito-marquez_greedy_2019] donde se define formalmente el problema, se desarrolla una solución mediante el algoritmo Feedy Randomized Adaptative Search Procedure (GRASP) y se estudia su comportamiento en la recogida de residuos de papel y cartón (residuo azul) y plástico (resiudo amarilla) en la isla de La Palma (Islas Canarias, España).

Aunque la formalización de estos problemas combinatorios es posible, su tratamiento y resolución mediante métodos exactos es complicada siendo, en muchos casos, intratable por las demandas computacionales. Con el objetivo de encontrar soluciones aproximadas en un tiempo razonable surgen los algoritmos metaheurísticos. Estos algoritmos suelen clasificarse en las siguientes familias:

- Locales 
- Globales
- De trayectoria
- De población

Algunas ventajas:

- La mayoría son *anytime*,
- Hacen pocas hipótesis acerca el problema de optimización a resolver por lo que permiten ser utilizados para una gran variedad de problemas.

Críticas [@sorensen_metaheuristics-metaphor_2015]:

- Falta de elaboración conceptual,
- Experimentación pobre,
- Ignorancia de literatura previa.

- Problema:
    - TSP  -> variantes
- Métodos metaheurísticos. En particular búsqueda Tabú y VNS

# Descripción del problema


El problema se puede describir formalmente como un grafo completo dirigido $\mathcal{G} = (\Theta, A)$ donde $\Theta=\{\theta_1,\ldots, \theta_n\}$ se corresponde con el conjunto de los $n$ emplazamientos y $A=\{(\theta_i,\theta_j):\theta_i,\theta_j\in\Theta, i\neq j\}$, las aristas del grafo. Además, el conjunto $\Theta = P \cup E$ de forma que $P\cap E = \emptyset$. Conocemos el tiempo de viaje entre dos emplazamientos $\theta_i, \theta_j$ al que denominaremos $d_{ij}>0$ y que, debido a la orografía del terreno y la infraestructura de carreteras, en general, $d_{ij}\neq d_{ji}$.

El conjunto de los puntos de recogida se recogen por una flota de vehículos $\mathcal{V} = \{v_1,\ldots, v_k\}$. El origen del vehículo $v\in\mathcal{V}$ se denomina como $o(v)\in E$ y $t(v)\in E$ al destino final del vehículo.

Se define un horizonte de predicción $\mathcal{H}=\{1,2,\ldots, h\}$.

$$
F_i(d) = \min\{1, f_i(d)\}
$$

Aunque la función de residuos acumulados $f_i(d)$ puede tomar cualquier forma, en este trabajo se ha considerado una función lineal $f_i(d) = b_i + q_i\cdot d$

# Formulación matemática

En esta sección expresaremos el problema de optimización que queremos resolver. Éste se puede formular como un problema de programación entera mixta (Mixed-Integer Programming o MIP). Necesitamos las siguientes variables:

- $X_{ijh}^v$: variable que toma valor $1$ si el vehículo $v\in\mathcal{V}$ va desde el punto $\theta_i$ hasta el $theta_j$ en el día $h\in \mathcal{H}$ y 0 en caso contrario, $\forall (\theta_i,\theta_j) \in A$
- $Y_{ih}^v$: toma valor $1$ si se visita el punto $\theta_i\in\Theta$ por el vehículo $v\in\mathcal{V}$ en el día $h\in\mathcal{H}$ y 0 en caso contrario.
- $\mathcal{T}_{ih}\in\mathbb{R}$: tiempo de recogida del punto $\theta_i\in\Theta$. Nótese que esta variable no depende de ningún vehículo ya que se considera que un punto de recogida solo se puede visitar por un único vehículo en un mismo día.

Así, las restricciones del problema son las siguientes:

$$
\sum_{j \in P} X_{o(v)jh}^v= 1 
$$

$$
\sum_{i \in P} X_{it(v)h}^v= 1 
$$

$$
\sum_{j\in\Theta}X_{jkh}^v = \sum_{j\in\Theta}X_{kjh}^v, k\in P,   
$$

$$
\sum_{j\in\Theta} X_{ijh}^v = Y_{ih}^v
$$
$$
\sum_{v\in \mathcal{V}} Y_{ih}^v \leq 1
$$

$$
T_{jh} \geq T_{ih} + s_i + t_{ij} - M\cdot \big(1-\sum_{v\in \mathcal{V}} X_{ijh}^v\big)
$$

$$
T_{ih} + s_i + t_{it(v)} \leq W_{vh}
$$

$$
X_{ijh}^v \in \{0, 1\}
$$

$$
Y_{ih}^v \in \{0, 1\}
$$
$$
T_{ih} \geq 0 
$$

El objetivo es

$$
\max \sum_{v \in V}\sum_{i\in P} \sum_{h\in H} F_i(\eta_{ih})\cdot Y_{ih}^v
$$

# Solution approach

En esta sección se describe la solución propuesta. La formulación matemática anterior es intratable computacionalmente cuando la dimensionalidad de los escenarios es alta [@exposito-marquez_greedy_2019], como es el caso del escenario de recogida de residuos en la isla de la Palma que utilizamos aquí. 

La solución propuesta busca diseñar las rutas que deben seguir cada vehículo cada uno de los días contenidos en el horizonte temporal. Para ello se aplica en la marco general de la búsqueda en vecindarios variables o VNS [@mladenovic_variable_1997] es un algoritmo metaheurístico para resolver problemas de optimización combinatorios y globales cuya principal idea es el cambio sistemático del vecindario de búsqueda tanto en un fase de búsqueda local como de una fase de perturbación que permita escapar de óptimos locales. Las distintas extensiones de este algoritmo se pueden consultar en [@gendreau_variable_2010]. El algoritmo VNS está basado en tres hechos fundamentales: (1) un mínimo local con respecto a una estructura de vecindario no lo es necesariamente respecto de otra, (2) un mínimo global es un mínimo local con respecto a todas las estructuras de vecindario posibles y (3) para muchos problemas, el mínimo local con respecto a uno o varios vecindarios están relativamente cercanos unos de otros. 

Aunque hay diferentes variantes del algoritmo VNS, una de las aproximaciones que más éxito han tenido es es la denominada General VNS [@gendreau_variable_2010]. Para definir este algoritmo comenzamos definiendo la función `NeighborhoodChange` que permite comparar los valores de dos soluciones de forma que, en caso de que la nueva solución sea mejor que la anterior, se actualiza la solución y se vuelve a usar el vecindario original $\mathcal{N}_1$. En caso contrario, se utiliza el siguiente vecindario. 

<!-- if $f(x')<f(x)$ then -->

<!-- $x<-x'$  -->
<!-- $k<-1$ -->
<!-- else -->

<!-- **NeighborhoodChange** -->

<!--  - $x' \leftarrow argmin_{y\in\mathcal{N}_k(x)}f(y)$ -->
<!--     - if $f(x')<f(x)$ then -->
<!--         - $x\leftarrow x'$ -->
<!--         - $k'\leftarrow 1$ -->
<!--     - else -->
<!--         - $k' \leftarrow k'+1$ -->
<!-- - return $x, k$ -->



<!-- - repeat -->
<!--     - $k\leftarrow 1$ -->
<!--     - repeat -->
<!--         - $w\leftarrow [1+Rand(0,1)\times |\mathcal{N}_k(x)|]$ -->
<!--         - $x'\leftarrow x^\omega$ -->
<!--         - $k'\leftarrow 1$ -->
<!--         - repeat -->
<!--             - $x' \leftarrow argmin_{y\in\mathcal{N}_k(x)}f(y)$ -->
<!--             - $x,k' \leftarrow NeighborhoodChange(x, x', k')$ -->
<!--         - until $k=k_{max}$ -->
<!--         - $x,k \leftarrow NeighborhoodChange(x, x', k)$ -->
<!--     - until $k=k_{max}$ -->
<!--     - $t\leftarrow CpuTime()$ -->
<!-- - until $t>t_{max}$ -->
<!-- return $x$ -->


**Inicialización.** Seleccionar el conjunto de las estructuras de vecindarios $\mathcal{N}_k$ para $k=1,\ldots, k_{max}$ que se usará en la búsqueda; encontrar una solución inicial $x$ y su valor de la función objetivo $f(x)$; asignar $x_{opt}\leftarrow x, f_{opt}\leftarrow f(x)$; elegir un critero de parada.

**Repetir** lo siguiente hasta que se satisfaga el criterio de parada:

  (1) Asignar $k\leftarrow 1$;
  (2) Repetir hasta que $k=k_{max}$:
        (a) **Agitación**. Generar un punto $x'$ aleatoriamente para el vecindario $\mathcal{N}_k(x)$;
        (b) $l\leftarrow 1$;
        (c) Repetir hasta que $l=l_{max}$:
            (i) **Búsqueda local.** Encontrar el mejor vecino en $\mathcal{N}_l(x')$ y denotarlo como $x''$;
            (ii) **Cambio de vecindario.** Si $f(x'') > f_{opt}$ hacer $f_{opt}\leftarrow f(x'')$, $x_{opt}\leftarrow x''$ y $l\leftarrow l_{max}$; en otro caso $l\leftarrow l + 1$;
        (d) **Mover o no.** Si $f(x'') < f_{opt}$, asignar $k \leftarrow k + 1$; en caso contrario, $k\leftarrow 1$.
          

Este algoritmo GVNS tiene varias extensiones, entre ellas la hibridación con otros algoritmos. Uno de los algoritmos metaheurísticos más utilizado es la búsqueda tabú. Esta algoritmo mantiene una *memoria* acerca de de la búsqueda ya realizada para prohibir (tabú) algunas soluciones recientes. Aunque se puede hibridar con GVNS de distintas formas, en este trabajo utilizaremos una hibridación de forma que el conjunto de soluciones vecinas esté limitado por la lista tabú. Así, el algoritmo anterior quedaría como


**Inicialización.** Seleccionar el conjunto de las estructuras de vecindarios $\mathcal{N}_k$ para $k=1,\ldots, k_{max}$ que se usará en la búsqueda; encontrar una solución inicial $x$ y su valor de la función objetivo $f(x)$; asignar $x_{opt}\leftarrow x, f_{opt}\leftarrow f(x)$; elegir un critero de parada; definir un conjunto de soluciones tabú $\mathcal{T}$.

**Repetir** lo siguiente hasta que se satisfaga el criterio de parada:

  (1) Asignar $k\leftarrow 1$;
  (2) Repetir hasta que $k=k_{max}$:
        (a) **Agitación**. Generar un punto $x'$ aleatoriamente para el vecindario $\mathcal{N}_k(x, \mathcal{T})$;
        (b) $l\leftarrow 1$;
        (c) Repetir hasta que $l=l_{max}$:
            (i) **Búsqueda local.** Encontrar el mejor vecino en $\mathcal{N}_l(x')$ y denotarlo como $x''$;
            (ii) **Cambio de vecindario.** Si $f(x'') > f_{opt}$ hacer $f_{opt}\leftarrow f(x'')$, $x_{opt}\leftarrow x''$, $l\leftarrow l_{max}$ y actualizar el conjunto tabú $\mathcal{T}$; en otro caso $l\leftarrow l + 1$;
        (d) **Mover o no.** Si $f(x'') < f_{opt}$, asignar $k \leftarrow k + 1$; en caso contrario, $k\leftarrow 1$.
          
          

# Características del problema

EL algoritmo definido en la sección anterior se puede aplicar a cualquier problema combinatorio. Para la aplicación del problema de optimización de recogida de residuos enunciado es necesario definir la estructura de los vecindarios y cómo se va a ir modificando la lista tabú.

Se consideran tres estructuras de vecindarios.

- Vecindario $\mathcal{N}_1$: dada una ruta, se añade un nuevo punto de recogida teniendo en cuenta que un punto de recogida no debe aparecer en dos rutas del mismo día.

- Vecindario $\mathcal{N}_2$: se intercambian dos puntos de recogida entre dos días distintos.

- Vecindario $\mathcal{N}_3$: se intercambia un punto de recogida que aparece en una de las rutas por uno que no haya sido recogido teniendo en cuenta, de nuevo, que un punto de recogida no puede ser recogido dos veces en el mismo día.


Cabe señalar que una de las principales restricciones del problema es el máximo tiempo que puede durar una ruta. Por tanto, en la búsqueda local en el vecindario de una solución, en el caso de que se encuentre algún vecino que, aunque tenga un valor de la función objetivo igual que la mejor solución, si ésta supone una disminución en el tiempo total de las rutas, se seleccionará esta solución.


Cada vez que se añade un punto de recogida a la solución, éste se introduce en la lista tabú $\mathcal{T}$. Además, es necesario definir un parámetro $\rho$ que especifique durante cuántas iteraciones un punto de recogida no se considerará desde que fue introducido en la lista $\mathcal{T}$.

En realidad, el problema se puede dividir en dos partes: (1) asignar un punto de recogida a una ruta y (2) elegir el orden adecuado en el que se deben visitar los puntos de recogida en esa ruta. Para esta segunda parte, se realiza una estrategia de mejora de la ruta mediante el heurístico Lin-Kernighan [@helsgaun_effective_2000] el cual se considera uno de las mejores heurísticas para aplicar al problema TSP. Este heurístico se implementa dentro de las soluciones obtenidas en las distintas estructuras de vecindario.

- $X = \mathcal{N}_k(x)$
- Repetir hasta encontrar una solución que verifique las restricciones:
    - Asignar a $x'$ la solución de $X$ con un mayor valor de la función objetivo; en caso de que haya varias soluciones posibles $x'$, se escoge aquella que tenga un menor tiempo total en las rutas.
    - Aplicar la heurística Lin-Kernighan a $x'$.
    - Si $x'$ no cumple las restricciones, $\mathcal{N}_k(x)\leftarrow \mathcal{N}_k(x) \setminus \{x'\}$





**Algoritmo shake**



Comenzamos definiendo los vecindarios.

Una ruta $r_h^v = (o(v), t(v))$


# Estructuras de vecindarios

Se definen tres estructuras de vecindarios:

- $\mathcal{N}_1$: añadir nuevos puntos de recogida.
 
Los vecinos de una solución se obtienen añadiendo un nuevo punto de recogida a las rutas. 

1. while improvement do:
    1. Improvement <- False
    1. For $\theta \in candidates$ do:
        1. For $v\in V$ do:
          1. For $h\in \mathcal{H}$ do:


- $\mathcal{N}_2$: intercambiar puntos de recogida.

Cada vecino se define como el intercambio entre rutas de puntos de recogida existentes. Es decir, dados dos camiones $v, v'\in \mathcal{V}$ (que puede darse $v = v'$) y dos días $d, d' \in \mathcal{H}$ de forma que $d\neq d'$, se escogen dos puntos de recogida $\theta\in R_{d}^v$ y $\theta\in R_{d'}^{v'}$ y se intercambian entre ellos.

- $\mathcal{N}_2$: cambiar puntos de recogida actuales por otros no considerados.

Los vecinos se obtienen al intercambiar un punto de recogida visitado en la solución actual en un día por otro que no haya sido visitado en ese día.

1. Inicialización:
    - $P_h=\,$ conjunto de puntos 
    - $\hat{\Theta}_h$: conjunto de puntos de recogida que no se visitan en el día $h$.
2. Repetir hasta mejorar:
    




## Vecindario 1: añadir punto de recogida

## Vecindario 2: intercambiar puntos de recogida entre días

## Vecindario 3: intercambiar punto de recogida con uno no visitado

# Vecindarios

## Vecindario 1: añadir

Sea $h\in\mathcal{H}$ un día del horizonte y $r_h$ la ruta de ese día tal que $r_i=(o(\nu), p_1, p_2, \ldots, p_n, t(\nu))$. Representamos todas las rutas como $R=\{r_1, r_2,\ldots, r_{|H|}\}$.

Este vecindario busca añadir un nuevo punto $p\in P(\nu)$ tal que el incremento en la función objetivo sea máximo.


## Vecindario 2: intercambiar entre días

## Vecindario 3: cambiar puntos de recogida

# Resultados computacionales

En esta sección se describen los resultados computacionales obtenidos en el escenario de análisis. Los objetivos de este análisis son:

1. Evaluar el comportamiento de la solución propuesta.
1. Comparar los resultados de la solución propuesta con la situación real actual y la solución propuesta en [@exposito-marquez_greedy_2019].
1. Evaluar el comportamiento de la solución en bajo diversos escenarios.

Los resultados computacionales que aparecen en esta sección se han realizado en un ordenador equipado con un procesador Intel Core i7-8700 3.20GHz y 16 GB de memoria RAM. La implementación de la solución se ha realizado utilizando el lenguaje de programación Python 3.8 recogido en el repositorio https://github.com/papabloblo/tfm. Se ha considerado un tiempo de ejecución de 4 horas, un tiempo asumible para la que la empresa de recogida pueda obbtener la planificación de las rutas y llevarlas a cabo. Nótese que el horizonte temporal es de 5 días así que, podría considerarse por parte de la empresa ejecutar el algoritmo diariamiente para ir recalculando las rutas si eso fuese posible y necesario utilizando como solución de inicial para el algoritmo las rutas planificadas.

En la sección 6.1 se describen los datos que componen el escenario bajo el que se realizan las pruebas computacionales.

## Resumen de los datos

El escenario sobre el que se aplica la solución propuesta se realiza sobre la isla de La Palma (Islas Canarias, España). Esta isla tiene una extensión de 708.32 $km^2$ con una población de 82,671 habitantes. [fuente: https://www.ine.es/jaxiT3/Datos.htm?t=2910#!tabs-tabla] La isla tiene como punto más elevado el Roque de los Muchachos (2426 metros). Está compuesta por 14 municipios. Su particular orografía y las conexiones entre los municipios, hace que las distancias y tiempos de viaje no sea simétricos. Además, se trata de una isla con un fuerte componente turístico son una media de 140,000 turistas anuales [¿CITA?].

Los datos utilizados para el estudio provienen de un caso real de estudio, descrito en detalle en [@exposito-marquez_greedy_2019]. Se contemplan dos escenarios de recogida de residuos y que constituyen problemas completamente independientes: residuos de papel y cartón (asociado al color azul) y residuos plásticos (asociado al color amarillo). Ambos escenarios comparten 338 puntos de recogida de los que se puede ver su situación en la figura X.

Los tiempos de viaje entre puntos de recogida se han obtenido a través de Google Distance Matrix API como una matriz $T$ de tamaño $N\times N$ siendo $N$ el número de puntos de recogida. Esta matriz tiene como características: (1) $t_{ii} = 0$, (2) $t_{ij} \geq 0$, $\forall i\neq j$ y (3), en general, $t_{ij}\neq t_{ji}$. En la matriz de distancias, la media de tiempo entre un punto de recogida y el punto de recogida más cercano es de 109.61 con una desviación típica de 111.47.

Un dato importante en el escenario es la forma en la que los puntos de recogida se van llenando de residuos. El modelo no impone de qué forma se debe producir este llenado. Se hace una simplificación de forma que se supone que el llenado se hace de forma lineal conforme a una tasa propia de cada punto de recogida. La tasa media de de llenado es de 0.134 con una desviación típica de 0.089 para la recogida de plásticos y 0.188 con una desviación típica de 0.108, para la recogida de cartones.

En ambos escenarios se considera que está disponible, diariamente, dos vehículos de recogida (uno para cada tipo de resiudo) sobre el que, a efectos prácticos, no se considera un límite de capacidad de residuos recogidos.

Para el primer escenario y poder realizar la comparativa con [@exposito-marquez_greedy_2019], se considera datos obtenidos en la semana del 2 al 6 de octubre para obtener el nivel de llenado en el día de partida de la optimización. El tiempo máximo en el que puede durar un ruta se correpsonde con 6.5 horas.



Los algoritmos descritos anteriormente se aplican en un contexto de recogida de residuos de la isla de la Palma. Se consideran un total de XX puntos de recogida entre los que se tiene un tiempo medio de viaje de XX. Además, tal y como aparece en [@exposito-marquez_greedy_2019], se ha considerado añadir un tiempo de recogida de cada punto de 120 segundos. Tiempo máximo de ruta: 6.5 horas. 

La orografía hace que los tiempos entre puntos de recogida no sea simétirca.

- Mapa de los puntos de recogida. [¡ESTO HAY QUE PEDIRLO!]

Para comprobar el comportamiento del algoritmo en otras situaciones a la descrita anteriormente, se llevan a cabo ejecuciones en la que el llenado inicial de los puntos de recogida se obtiene aleatoriamente. Esto permite comprobar con generalidad el comportamiento del algoritmo. Como la recogida total de residuo se ve afectada por la cantidad de residuo inicial en cada punto de recogida, para la comparativa se ha utilizado el indicador en función del.

Sabiendo que el llenado de los puntos de recogida se produce con la fórmula 

$$
r_i = a_i + b_i\cdot d
$$
Si no consideramos el desbordamiento de los contenedores, el residuo acumulado de los puntos de recogida, considerando un horizon de $h$ días sería

$$
r_i = a_i + b_i\cdot h
$$

Así, podemos tener el siguiente indicador. Sea $f$ la cantidad de residuo recogido por una solución,

$$
indicador = \frac{f}{\sum_{i\in\Theta} r_i}
$$
Este indicador nos permitirá obtener el procentaje del residuo recogido del total de residuo generado durante el horizonte de planificación y poder comparar los distintos escenarios.

Métrica para calcular los puntos de recogida saturados

Dada una ruta $r$, será interesante tener en cuenta la satisfacción del servicio que puedan percibir los usuarios. Un indicador clave es que los puntos de recogida no estén desbordados lo que conlleva la posible acumulación de residuos fuera de él o que el usuario tenga que desplazarse hasta otro punto de recogida cercano que no es esté desbordado. De aquí podemos obtener dos indicadores:

- Número de puntos de recogida que se desbordan en algún momento durante el horizonte de planificación,
- Cantidad de residuo "desbordado". (Diferencia entre el residuo téorico y el resiudo recogido en el caso de que se produzca un desbordamiento)



# Conclusiones y trabajo futuro

